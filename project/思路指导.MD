12.3.1 创建 Pygame 窗口以及响应用户输入

12.3.2 设置背景色
    Pygame默认创建一个黑色屏幕，这太乏味了。

12.3.3 创建设置类
    每次给游戏添加新功能时，通常也将引入一些新设置。下面来编写一个名为settings的模块，
其中包含一个名为Settings的类，用于将所有设置存储在一个地方，以免在代码中到处添加设置。
这样，我们就能传递一个设置对象，而不是众多不同的设置。另外，这让函数调用更简单，且在
项目增大时修改游戏的外观更容易：要修改游戏，只需修改settings.py中的一些值，而无需查找
散布在文件中的不同设置

12.4 添加飞船图像
    为了在屏幕上绘制玩家的飞船，我们将加载一幅图像，再使用
Pygame方法blit()绘制它。

12.4.1 创建 Ship 类
    选择用于表示飞船的图像后，需要将其显示到屏幕上。我们将创建一个名为ship的模块，其
中包含Ship类，它负责管理飞船的大部分行为

12.4.2 在屏幕上绘制飞船
    下面来更新alien_invasion.py，使其创建一艘飞船，并调用其方法blitme()：

12.5 重构：模块 game_functions
    在大型项目中，经常需要在添加新代码前重构既有代码。重构旨在简化既有代码的结构，使
其更容易扩展

12.5.1 函数 check_events()
    我们将首先把管理事件的代码移到一个名为check_events()的函数中，以简化run_game()并
隔离事件管理循环。通过隔离事件循环，可将事件管理与游戏的其他方面（如更新屏幕）分离

12.5.2 函数 update_screen()
    为进一步简化run_game()，下面将更新屏幕的代码移到一个名为update_screen()的函数中，
并将这个函数放在模块game_functions.py中：

12.6 驾驶飞船
    下面来让玩家能够左右移动飞船。为此，我们将编写代码，在用户按左或右箭头键时作出响
应。我们将首先专注于向右移动，再使用同样的原理来控制向左移动。通过这样做，你将学会如
何控制屏幕图像的移动

12.6.1 响应按键
    每当用户按键时，都将在Pygame中注册一个事件。事件都是通过方法pygame.event.get()获
取的，因此在函数check_events()中，我们需要指定要检查哪些类型的事件。每次按键都被注册
为一个KEYDOWN事件
    检测到KEYDOWN事件时，我们需要检查按下的是否是特定的键。例如，如果按下的是右箭头
键，我们就增大飞船的rect.centerx值，将飞船向右移动

12.6.2 允许不断移动
    玩家按住右箭头键不放时，我们希望飞船不断地向右移动，直到玩家松开为止。我们将让游
戏检测pygame.KEYUP事件，以便玩家松开右箭头键时我们能够知道这一点；然后，我们将结合使
用KEYDOWN和KEYUP事件，以及一个名为moving_right的标志来实现持续移动

12.6.3 左右移动
    飞船能够不断地向右移动后，添加向左移动的逻辑很容易。我们将再次修改Ship类和函数
check_events()

12.6.4 调整飞船的速度
    每次执行while循环时，飞船最多移动1像素，但我们可以在Settings类中添加属性
ship_speed_factor，用于控制飞船的速度

12.6.5 限制飞船的活动范围
    如果玩家按住箭头键的时间足够长，飞船将移到屏幕外面，消失得无影无踪。下面来
修复这种问题，让飞船到达屏幕边缘后停止移动。为此，我们将修改Ship类的方法update()

12.6.6 重构 check_events()
    随着游戏开发的进行，函数check_events()将越来越长，我们将其部分代码放在两个函数中：
一个处理KEYDOWN事件，另一个处理KEYUP事件

12.7 简单回顾
    下一节将添加射击功能，这需要新增一个名为bullet.py的文件，并对一些既有文件进行修改。
当前，我们有四个文件，其中包含很多类、函数和方法。添加其他功能之前，为让你清楚这个项
目的组织结构，先来回顾一下这些文件
12.7.1 alien_invasion.py 
    主文件alien_invasion.py创建一系列整个游戏都要用到的对象：存储在ai_settings中的设置、
存储在screen中的主显示surface以及一个飞船实例。文件alien_invasion.py还包含游戏的主循环，
这是一个调用check_events()、ship.update()和update_screen()的while循环。
要 玩 游 戏 《 外 星 人 入 侵 》， 只 需 运 行 文 件alien_invasion.py。其他文件（settings.py、
game_functions.py、ship.py）包含的代码被直接或间接地导入到这个文件中
12.7.2 settings.py
    文件settings.py包含Settings类，这个类只包含方法__init__()，它初始化控制游戏外观和飞
船速度的属性。
12.7.3 game_functions.py
    件game_functions.py包含一系列函数，游戏的大部分工作都是由它们完成的。函数
check_events()检测相关的事件，如按键和松开，并使用辅助函数check_keydown_events()和
check_keyup_events()来处理这些事件。就目前而言，这些函数管理飞船的移动。模块
game_functions还包含函数update_screen()，它用于在每次执行主循环时都重绘屏幕

12.8 射击
    下面来添加射击功能。我们将编写玩家按空格键时发射子弹（小矩形）的代码。子弹将在屏
幕中向上穿行，抵达屏幕上边缘后消失
12.8.1 添加子弹设置
    更新settings.py，在其方法__init__()末尾存储新类Bullet所需的值

12.8.2 创建 Bullet 类    
    Bullet类继承了我们从模块pygame.sprite中导入的Sprite类。通过使用精灵，可将游戏中相
关的元素编组，进而同时操作编组中的所有元素。为创建子弹实例，需要向__init__()传递
ai_settings、screen和ship实例，还调用了super()来继承Sprite

12.8.3 将子弹存储到编组中
    定义Bullet类和必要的设置后，就可以编写代码了，在玩家每次按空格键时都射出一发子弹。
首先，我们将在alien_invasion.py中创建一个编组（group），用于存储所有有效的子弹，以便能够
管理发射出去的所有子弹

12.8.4 开火
    在game_functions.py中，我们需要修改check_keydown_events()，以便在玩家按空格键时发射
一颗子弹。我们无需修改check_keyup_events()，因为玩家松开空格键时什么都不会发生。我们
还需修改update_screen()，确保在调用flip()前在屏幕上重绘每颗子弹

12.8.5 删除已消失的子弹
    子弹抵达屏幕顶端后消失，这仅仅是因为Pygame无法在屏幕外面绘制它们。这些子
弹实际上依然存在，它们的y坐标为负数，且越来越小。这是个问题，因为它们将继续消耗内存
和处理能力。
    在for循环中，不应从列表或编组中删除条目，因此必须遍历编组的副本。我们使用了方法
copy()来设置for循环，这让我们能够在循环中修改bullets

12.8.6 限制子弹数量
    很多射击游戏都对可同时出现在屏幕上的子弹数量进行限制，以鼓励玩家有目标地射击
    
12.8.7 创建函数 update_bullets()
    编写并检查子弹管理代码后，可将其移到模块game_functions中，以让主程序文件
alien_invasion.py尽可能简单

12.8.8 创建函数 firebullet()
    下面将发射子弹的代码移到一个独立的函数中，这样，在check_keydown_events()中只需使
用一行代码来发射子弹，让elif代码块变得非常简单

13.1 回顾项目
    开发较大的项目时，进入每个开发阶段前回顾一下开发计划，搞清楚接下来要通过编写代码
来完成哪些任务都是不错的主意

13.2 创建第一个外星人
    在屏幕上放置外星人与放置飞船类似。每个外星人的行为都由Alien类控制，我们将像创建
Ship类那样创建这个类

13.2.1 创建 Alien 类
    下面来编写Alien类

13.2.2 创建 Alien 实例
    下面在alien_invasion.py中创建一个Alien实例

13.3 创建一群外星人
    要绘制一群外星人，需要确定一行能容纳多少个外星人以及要绘制多少行外星人。我们将首
先计算外星人之间的水平间距，并创建一行外星人，再确定可用的垂直空间，并创建整群外星人
13.3.1 确定一行可容纳多少个外星人
    为确定一行可容纳多少个外星人，我们来看看可用的水平空间有多大。屏幕宽度存储在
ai_settings.screen_width中，但需要在屏幕两边都留下一定的边距，把它设置为外星人的宽度

13.3.2 创建多行外星人
    为创建一行外星人，首先在alien_invasion.py中创建一个名为aliens的空编组，用于存储全部
外星人，再调用game_functions.py中创建外星人群的函数

13.3.3 创建外星人群
    现在可以创建外星人群了。下面是新函数create_fleet()，我们将它放在game_functions. 
py的末尾

13.3.4 重构 create_fleet()
    倘若我们创建了外星人群，也许应该让create_fleet()保持原样，但鉴于创建外星人的工作
还未完成，我们稍微清理一下这个函数。下面是create_fleet()和两个新函数，get_number_ 
aliens_x()和create_alien()

13.3.5 添加行
    要创建外星人群，需要计算屏幕可容纳多少行，并对创建一行外星人的循环重复相应的次数。

13.4 让外星人群移动
    下面来让外星人群在屏幕上向右移动，撞到屏幕边缘后下移一定的距离，再沿相反的方向移
动。我们将不断地移动所有的外星人，直到所有外星人都被消灭，有外星人撞上飞船，或有外星
人抵达屏幕底端。下面先来让外星人向右移动
13.4.1 向右移动外星人
    为移动外星人，我们将使用alien.py中的方法update()，且对外星人群中的每个外星人都调用
它。首先，添加一个控制外星人速度的设置

13.4.2 创建表示外星人移动方向的设置
    下面来创建让外星人撞到屏幕右边缘后向下移动、再向左移动的设置

13.4.3 检查外星人是否撞到了屏幕边缘
    现在需要编写一个方法来检查是否有外星人撞到了屏幕边缘，还需修改update()，以让每个
外星人都沿正确的方向移动

13.4.4 向下移动外星人群并改变移动方向
    有外星人到达屏幕边缘时，需要将整群外星人下移，并改变它们的移动方向。我们需要对
game_functions.py做重大修改，因为我们要在这里检查是否有外星人到达了左边缘或右边缘.

13.5 射杀外星人
    我们创建了飞船和外星人群，但子弹击中外星人时，将穿过外星人，因为我们还没有检查碰
撞。在游戏编程中，碰撞指的是游戏元素重叠在一起。要让子弹能够击落外星人，我们将使用
sprite.groupcollide()检测两个编组的成员之间的碰撞
13.5.1 检测子弹与外星人的碰撞
    子弹击中外星人时，我们要马上知道，以便碰撞发生后让外星人立即消失。为此，我们将在
更新子弹的位置后立即检测碰撞

13.5.2 为测试创建大子弹
    只需通过运行这个游戏就可以测试其很多功能，但有些功能在正常情况下测试起来比较烦
琐。例如，要测试代码能否正确地处理外星人编组为空的情形，需要花很长时间将屏幕上的外星
人都击落

13.5.3 生成新的外星人群
    这个游戏的一个重要特点是外星人无穷无尽，一个外星人群被消灭后，又会出现一群外星人。
要在外星人群被消灭后又显示一群外星人，首先需要检查编组aliens是否为空。如果为空，
就调用create_fleet().我们将在update_bullets()中执行这种检查，因为外星人都是在这里被
消灭的

13.5.4 提高子弹的速度
    为提高子弹的速度，可调整 settings.py 中
bullet_speed_factor的值。例如，如果将这个值增大到3，子弹在屏幕上向上穿行的速度将变得
相当快

13.5.5 重构 update_bullets()

13.6 结束游戏
    如果玩家根本不会输，游戏还有什么趣味和挑战性可言？如果玩家没能在足够短的时间内将
整群外星人都消灭干净，且有外星人撞到了飞船，飞船将被摧毁。与此同时，我们还限制了可供
玩家使用的飞船数，而有外星人抵达屏幕底端时，飞船也将被摧毁。玩家用光了飞船后，游戏便
结束
13.6.1 检测外星人和飞船碰撞
    我们首先检查外星人和飞船之间的碰撞，以便外星人撞上飞船时我们能够作出合适的响应。
我们在更新每个外星人的位置后立即检测外星人和飞船之间的碰撞。

13.6.2 响应外星人和飞船碰撞
    现在需要确定外星人与飞船发生碰撞时，该做些什么。我们不销毁ship实例并创建一个新的
ship实例，而是通过跟踪游戏的统计信息来记录飞船被撞了多少次（跟踪统计信息还有助于记
分）
下面来编写一个用于跟踪游戏统计信息的新类——GameStats，并将其保存为文件
game_stats.py

13.6.3 有外星人到达屏幕底端
    如果有外星人到达屏幕底端，我们将像有外星人撞到飞船那样作出响应。请添加一个执行这
项任务的新函数，并将其命名为update_aliens()

13.6.4 游戏结束
    现在这个游戏看起来更完整了，但它永远都不会结束，只是ships_left不断变成更小的负数。
下面在GameStats中添加一个作为标志的属性game_active，以便在玩家的飞船用完后结束游戏

13.7 确定应运行游戏的哪些部分

14.1 添加 Play 按钮
    在本节中，我们将添加一个Play按钮，它在游戏开始前出现，并在游戏结束后再次出现，让
玩家能够开始新游戏。

14.1.1 创建 Button 类
    由于Pygame没有内置创建按钮的方法，我们创建一个Button类，用于创建带标签的实心矩形。
你可以在游戏中使用这些代码来创建任何按钮

14.1.2 在屏幕上绘制按钮
    我们将使用Button类来创建一个Play按钮。鉴于只需要一个Play按钮，我们直接在
alien_invasion.py中创建它

14.1.3 开始游戏
    为在玩家单击Play按钮时开始新游戏，需在game_functions.py中添加如下代码，以监视与这
个按钮相关的鼠标事件

14.1.4 重置游戏
    前面编写的代码只处理了玩家第一次单击Play按钮的情况，而没有处理游戏结束的情况，因
为没有重置导致游戏结束的条件

14.1.5 将 Play 按钮切换到非活动状态
    当前，Play按钮存在一个问题，那就是即便Play按钮不可见，玩家单击其原来所在的区域时，
游戏依然会作出响应。游戏开始后，如果玩家不小心单击了Play按钮原来所处的区域，游戏将重
新开始！
为修复这个问题，可让游戏仅在game_active为False时才开始

14.1.6 隐藏光标
    为让玩家能够开始游戏，我们要让光标可见，但游戏开始后，光标只会添乱。为修复这种问
题，我们在游戏处于活动状态时让光标不可见

14.2 提高等级
    将整群外星人都消灭干净后，玩家将提高一个等级，但游戏的难度并没有变。下面
来增加一点趣味性：每当玩家将屏幕上的外星人都消灭干净后，加快游戏的节奏，让游戏玩起
来更难
14.2.1 修改速度设置
    我们首先重新组织Settings类，将游戏设置划分成静态的和动态的两组。对于随着游戏进行
而变化的设置，我们还确保它们在开始新游戏时被重置

14.2.2 重置速度
    每当玩家开始新游戏时，我们都需要将发生了变化的设置重置为初始值，否则新游戏开始时，
速度设置将是前一次游戏增加了的值

14.3 记分
    下面来实现一个记分系统，以实时地跟踪玩家的得分，并显示最高得分、当前等级和余下的
飞船数。
得分是游戏的一项统计信息，因此我们在GameStats中添加一个score属性

14.3.1 显示得分
    为在屏幕上显示得分，我们首先创建一个新类Scoreboard。就当前而言，这个类只显示当前
得分，但后面我们也将使用它来显示最高得分、等级和余下的飞船数

14.3.3 在外星人被消灭时更新得分
    为在屏幕上实时地显示得分，每当有外星人被击中时，我们都更新stats.score的值，再调
用prep_score()更新得分图像。但在此之前，我们需要指定玩家每击落一个外星人都将得到多少
个点

14.3.4 将消灭的每个外星人的点数都计入得分
    当前，我们的代码可能遗漏了一些被消灭的外星人。例如，如果在一次循环中有两颗子弹射
中了外星人，或者因子弹更宽而同时击中了多个外星人，玩家将只能得到一个被消灭的外星人的
点数；为修复这种问题，我们来调整检测子弹和外星人碰撞的方式。

14.3.5 提高点数
    玩家每提高一个等级，游戏都变得更难，因此处于较高的等级时，外星人的点数应更高。为实现这种功能，
我们添加一些代码，以在游戏节奏加快时提高点数

14.3.6 将得分圆整
    大多数街机风格的射击游戏都将得分显示为10的整数倍，下面让我们的记分系统遵循这个原
则。我们还将设置得分的格式，在大数字中添加用逗号表示的千位分隔符

14.3.7 最高得分
    每个玩家都想超过游戏的最高得分记录。下面来跟踪并显示最高得分，给玩家提供要超越的
目标。我们将最高得分存储在GameStats中

14.3.8 显示等级
    为在游戏中显示玩家的等级，首先需要在GameStats中添加一个表示当前等级的属性。为确
保每次开始新游戏时都重置等级，在reset_stats()中初始化它

14.3.9 显示余下的飞船数
    最后，我们来显示玩家还有多少艘飞船，但使用图形而不是数字。为此，我们在屏幕左上角
绘制飞船图像来指出还余下多少艘飞船，就像众多经典的街机游戏那样
    首先，需要让Ship继承Sprite，以便能够创建飞船编组








