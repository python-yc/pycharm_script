##正则的写法
- .(点号)：表示任意一个字符，除了\n，比如查找所有的一个字符 \.
- []：匹配方括号中列举的任意字符，比如[L,Y] 或者这样写[LY]
- \d：任意一个数字
- \D：除了数字都可以
- \s：表示空格、tab键
- \S：除了空白符号都可以
- \w：单词字符，就是a-z，A-Z，0-9，_
- \W：除了小w中的都可以
- *：表示前面内容重复0或者多次，单个表示所有，例如 \w*  表示只要有字符，只能是a-z，A-Z，0-9，_中的一个或者多个；
再如：ab.*表示含有ab的或者倍数的字符返回,ab12、adc、ababa
- +：表示前面内容至少出现一次
- ?：前面出现的内容重复0或者1次
- {m,n}：允许前面的内容最少出现m次，最多n次
- ^：匹配字符串以前面的开头
- $：匹配字符串以前面的结尾
- \b：匹配单词的边界
- ()：对正则表达式内容进行分组，从第一个括号开始，编号逐渐增大
- 一些案例
    验证一个数字： ^\d$
    必须有一个数字，最少一位： ^\d+$     表示的开头或结尾至少有一个数字的
    只能出现数字，且位数为5-10位： ^\d{5,10}$
    注册者输入年龄，要求16岁以上，99岁以下： ^[16-99]$
    只能输入英文字符和数字： ^[A-Za-z0-9]$  (注意这个中间无分隔符)
    验证qq号码： [0-9]{5,12}
- \A：只能匹配字符串开头， \Aabcd，则abcd
- \Z：仅匹配字符串末尾， abcd\Z,abcd
- |：左右任意一个
- (?P<name>...)：分组，除了原来的编号再定制一个别名，(?P<id>12345){2}
- (?P=name)：引用分组

ret = re.search('(?P<id>.+\d{3})/(?P<name>\w{3})','www122/ooo')
print(ret.group('id'))  # www12
print(ret.group('name'))    # ooo
print(ret.group())
print(ret.group(1))
print(ret.groups())
print(ret.groupdict())

括号() 的分组在正则匹配是可以引用的，那么如果这种() 非常多，都写 \1 \2 \3 肯定不是很方便，那么下面有一种命名的编写方式。
分组别名引用：(?P<name>) (?P=name)
字符	        功能
(?P<name>)	    分组起别名
(?P=name)	    引用别名为name分组匹配到的字符串
 特别适合于html中

(?P=name) 为了配合 (?P<name>)使用的

- #r表示字符串不转义
    - p = re.compile(r'\d+')
# 3.2 re使用大致步骤
1、使用compile将表示正则的字符串辩证为一个pattern对象
2、通过pattern对象提供一系列方法对文本进行匹配查找，获得匹配结果，一个Match对象
3、最后使用Match对象提供属性和方法获得信息，根据需要进行操作
# 3.3 re常用函数
- group():获得一个或者多个分组匹配的字符串，当要获得整个匹配的子字符串，直接group()/group(0)

- match(s[, begin, end]):默认从开头匹配;match 对象才有下面三个方法
    - 即：m = p.match("one12twothree33456four78", 3, 10)
    m.start()/m.end()/m.span()
- start()：获取开头下标；获取分组匹配的子串在整个字符串中的真实位置，参数默认为0
- end()：获取结尾下标；获取分组匹配的子串在整个字符串中的结束位置，默认为0
- span()：返回的结构技术(start(group),end(group))
- 案例re-eg
# 查找
- search(str,[,pos[,endpos]])：在字符串中查找匹配，pos和endpos表示起始位置和结束位置
- findall：查找所有
- finditer：查找，返回一个iter结果
- 案例re-eg
# sub 替换
- sub(repl,str[,count])
- 案例re-eg
# 匹配中文
- 大部分中文内容范围是[u4e00-u9fa5]，但不包括全角标点
- 案例re-eg
# 贪婪非贪婪
- 贪婪：尽可能多的匹配，(*)表示贪婪匹配
- 非贪婪：找到符合条件的最小内容即可，(?)表示非贪婪，而且依赖+、*，不能单独出现。同时使用也都需要点号(.)占位
- 正则默认使用贪婪匹配
- 案例re-eg

