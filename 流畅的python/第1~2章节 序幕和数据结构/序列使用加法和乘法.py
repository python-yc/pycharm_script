# -*- coding: utf-8 -*-

"""
Python程序员会默认序列是支持+和*操作的。通常+号两侧的序列由相同类型的数据所构成，
在拼接的过程中，两个被操作的序列都不会被修改，Python会新建一个包含同样类型数据的
序列来作为拼接的结果
"""
l = [1, 2, 3]
print(l * 5)

print(5 * 'abcd')

# 一个包含3个列表的列表，嵌套的3个列表各自有3个元素来代表井字游戏的一行方块
board = [['_'] * 3 for i in range(3)]
board[1][2] = 'X'
print(board)

# 以上等同于;每次迭代中都新建了一个列表，作为新的一行（row）追加到游戏板（board）
for i in range(3):
    row = ['_'] * 3
    board.append(row)

"""
如果在a*n这个语句中，序列a里的元素是对其他可变对象的引用的话，你就需要格外
注意了，因为这个式子的结果可能会出乎意料。比如，你想用my_list=[[]]*3来初始
化一个由列表组成的列表，但是你得到的列表里包含的3个元素其实是3 个引用，而且
这3个引用指向的都是同一个列表。这可能不是你想要的效果
"""
weird_board = [['_'] * 3] * 3
weird_board[1][2] = 'N'
print(weird_board)

# 追加同一个行对象（row）3次到游戏板（board）,一旦修改一个值就能看出结果了
row = ['_'] * 3
for i in range(3):
    board.append(row)


# 首先是元祖是不可变列表，因此不能使用追加之类的操作，但是如下这个奇特例子也是奇特
## 这其实是个非常罕见的边界情况，

"""因此：不要把可变对象放在元组里面"""
# 如果写成t[2].extend([50,60])就能避免这个异常。确实是这样，但这个例子是为了展示这种奇怪的现象而专门写的
t = (1, 2, [30, 40])
# t[2] += [50, 60]    # TypeError: 'tuple' object does not support item assignment
print(type(t[2]))
t[2].extend([50,60])
print(t)
