# -*- coding: utf-8 -*-

"""
最快的时间来自“集合交集花费时间”这一列，这一列的结果是示例3-15中利用集合&操作的代码的效果。

不出所料的是，最糟糕的表现来自 “列表花费时间” 这一列。由于列表的背后没有散列表来支持in运算符，
每次搜索都需要扫描一次完整的列表，导致所需的时间跟据haystack的大小呈线性增长
"""

'''
列表是最耗时的;  
 
字典：
字典在内存上的开销巨大；
键查询很快；
键的次序取决于添加顺序；

集合(与字典性质类似)：
集合很消耗内存；
可以很高效地判断元素是否存在于某个集合；
元素的次序取决于被添加到集合里的次序；

速度是以牺牲空间为代价而换来的.
'''

"""
如果在你的程序里有任何的磁盘输入/输出，那么不管查询有多少个元素的字典或集合，
所耗费的时间都能忽略不计（前提是字典或者集合不超过内存大小）
"""

"""
如果你需要存放数量巨大的记录，那么放在由元组或是具名元组构成的列表中会是比较好的选择;
在用户自定义的类型中，__slots__属性可以改变实例属性的存储方式，由dict变成tuple，
相关细节在流畅的python中9.8节会谈到
"""
